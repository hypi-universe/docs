"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[8547],{3905:function(e,t,a){a.d(t,{Zo:function(){return p},kt:function(){return h}});var n=a(7294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},l=Object.keys(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(n=0;n<l.length;n++)a=l[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),u=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},p=function(e){var t=u(e.components);return n.createElement(s.Provider,{value:t},e.children)},c={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=u(a),h=r,m=d["".concat(s,".").concat(h)]||d[h]||c[h]||l;return a?n.createElement(m,o(o({ref:t},p),{},{components:a})):n.createElement(m,o({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=a.length,o=new Array(l);o[0]=d;var i={};for(var s in t)hasOwnProperty.call(t,s)&&(i[s]=t[s]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var u=2;u<l;u++)o[u]=a[u];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}d.displayName="MDXCreateElement"},1332:function(e,t,a){var n=a(7294);t.Z=function(e){var t=e.children,a=e.hidden,r=e.className;return n.createElement("div",{role:"tabpanel",hidden:a,className:r},t)}},8515:function(e,t,a){a.d(t,{Z:function(){return p}});var n=a(7462),r=a(7294),l=a(2389),o=a(5394),i=a(6010),s="tabItem_tAz6";function u(e){var t,a,l,u=e.lazy,p=e.block,c=e.defaultValue,d=e.values,h=e.groupId,m=e.className,y=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&void 0!==e.props.value)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),f=null!=d?d:y.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),g=(0,o.lx)(f,(function(e,t){return e.value===t.value}));if(g.length>0)throw new Error('Docusaurus error: Duplicate values "'+g.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===c?c:null!=(t=null!=c?c:null==(a=y.find((function(e){return e.props.default})))?void 0:a.props.value)?t:null==(l=y[0])?void 0:l.props.value;if(null!==v&&!f.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+f.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var k=(0,o.UB)(),b=k.tabGroupChoices,w=k.setTabGroupChoices,N=(0,r.useState)(v),T=N[0],E=N[1],j=[],q=(0,o.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var Q=b[h];null!=Q&&Q!==T&&f.some((function(e){return e.value===Q}))&&E(Q)}var C=function(e){var t=e.currentTarget,a=j.indexOf(t),n=f[a].value;n!==T&&(q(t),E(n),null!=h&&w(h,n))},L=function(e){var t,a=null;switch(e.key){case"ArrowRight":var n=j.indexOf(e.currentTarget)+1;a=j[n]||j[0];break;case"ArrowLeft":var r=j.indexOf(e.currentTarget)-1;a=j[r]||j[j.length-1]}null==(t=a)||t.focus()};return r.createElement("div",{className:"tabs-container"},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":p},m)},f.map((function(e){var t=e.value,a=e.label,l=e.attributes;return r.createElement("li",(0,n.Z)({role:"tab",tabIndex:T===t?0:-1,"aria-selected":T===t,key:t,ref:function(e){return j.push(e)},onKeyDown:L,onFocus:C,onClick:C},l,{className:(0,i.Z)("tabs__item",s,null==l?void 0:l.className,{"tabs__item--active":T===t})}),null!=a?a:t)}))),u?(0,r.cloneElement)(y.filter((function(e){return e.props.value===T}))[0],{className:"margin-vert--md"}):r.createElement("div",{className:"margin-vert--md"},y.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==T})}))))}function p(e){var t=(0,l.Z)();return r.createElement(u,(0,n.Z)({key:String(t)},e))}},1915:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return u},contentTitle:function(){return p},metadata:function(){return c},toc:function(){return d},default:function(){return m}});var n=a(7462),r=a(3366),l=(a(7294),a(3905)),o=a(8515),i=a(1332),s=["components"],u={id:"gql-schema-types",title:"GraphQL Schema and Types",sidebar_label:"GraphQL Schema and Types",slug:"/lowcode/gql-schema-types"},p=void 0,c={unversionedId:"lowcode/gql-schema-types",id:"lowcode/gql-schema-types",title:"GraphQL Schema and Types",description:"On this page, you'll learn all you need to know about the GraphQL type system and GraphQL Schema to define the data. Since GraphQL can be used with any backend framework or programming language, we'll stay away from implementation-specific details and talk only about the concepts.",source:"@site/content/lowcode/gql-schema-types.md",sourceDirName:"lowcode",slug:"/lowcode/gql-schema-types",permalink:"/docs/lowcode/gql-schema-types",editUrl:"https://github.com/hypi-universe/docs/edit/master/content/lowcode/gql-schema-types.md",tags:[],version:"current",frontMatter:{id:"gql-schema-types",title:"GraphQL Schema and Types",sidebar_label:"GraphQL Schema and Types",slug:"/lowcode/gql-schema-types"},sidebar:"docs",previous:{title:"GraphQL Introduction",permalink:"/docs/lowcode/gql-introduction"},next:{title:"GraphQL Queries",permalink:"/docs/lowcode/gql-queries"}},d=[{value:"Type system",id:"type-system",children:[],level:3},{value:"Type language",id:"type-language",children:[],level:3},{value:"Object types and fields",id:"object-types-and-fields",children:[],level:3},{value:"Arguments",id:"arguments",children:[],level:3},{value:"The Query and Mutation types",id:"the-query-and-mutation-types",children:[],level:3},{value:"Scalar types",id:"scalar-types",children:[],level:3},{value:"Enumeration types",id:"enumeration-types",children:[],level:3},{value:"Lists and Non-Null",id:"lists-and-non-null",children:[],level:3}],h={toc:d};function m(e){var t=e.components,a=(0,r.Z)(e,s);return(0,l.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,l.kt)("p",null,"On this page, you'll learn all you need to know about the GraphQL type system and GraphQL Schema to define the data. Since GraphQL can be used with any backend framework or programming language, we'll stay away from implementation-specific details and talk only about the concepts."),(0,l.kt)("h3",{id:"type-system"},"Type system"),(0,l.kt)("p",null,"If you've seen a GraphQL query before, you know that the GraphQL query language is basically about selecting fields on objects. So, for example, in the following query:"),(0,l.kt)(o.Z,{defaultValue:"query",values:[{label:"GraphQL Query",value:"query"},{label:"Input Data",value:"data"},{label:"Response",value:"response"}],mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"query",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"query getMyTodos($arcql:String) {\n   todos(arcql:$arcql) {\n     hypi {\n        id\n        created\n      }\n     description\n     completed\n   }\n}\n"))),(0,l.kt)(i.Z,{value:"data",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre"},'{\n    "arcql": "* SORT hypi.updated DESC"\n}\n'))),(0,l.kt)(i.Z,{value:"response",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n   "data": {\n     "todos": [\n       {\n          "hypi": {\n           "id": "c94144ec-52aa-4337-9d8b-15fa8ec5c979"\n           "created": "2019-11-02T15:45:16Z"\n           }\n          "description": "Buy milk for the office",\n          "completed":"false",\n       },\n       ]\n     }\n}\n')))),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"We start with a special ",(0,l.kt)("inlineCode",{parentName:"li"},"root")," object (",(0,l.kt)("inlineCode",{parentName:"li"},"query")," for request and ",(0,l.kt)("inlineCode",{parentName:"li"},"data")," for response)"),(0,l.kt)("li",{parentName:"ul"},"We select the ",(0,l.kt)("inlineCode",{parentName:"li"},"todos")," field on that"),(0,l.kt)("li",{parentName:"ul"},"For the object returned by todos, we select the ",(0,l.kt)("inlineCode",{parentName:"li"},"description")," and ",(0,l.kt)("inlineCode",{parentName:"li"},"completed")," fields")),(0,l.kt)("p",null,"Because the shape of a GraphQL query closely matches the result, you can predict what the query will return without knowing that much about the server. But it's useful to have an exact description of the data we can ask for - what fields can we select? What kinds of objects might they return? What fields are available on those sub-objects? That's where the schema comes in."),(0,l.kt)("p",null,"Every GraphQL service defines a set of types that completely describe the set of possible data you can query on that service. Then, when queries come in, they are validated and executed against that schema."),(0,l.kt)("h3",{id:"type-language"},"Type language"),(0,l.kt)("p",null,"GraphQL services can be written in any language. Since we can't rely on a specific programming language syntax, like JavaScript, to talk about GraphQL schemas, we'll define our own simple language. We'll use the \"GraphQL schema language\" - it's similar to the query language and allows us to talk about GraphQL schemas in a language-agnostic way."),(0,l.kt)("h3",{id:"object-types-and-fields"},"Object types and fields"),(0,l.kt)("p",null,"The most basic components of a GraphQL schema are object types, which just represent a kind of object you can fetch from your service. The object has fields of various types. In the GraphQL schema language, we might represent it like this:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"type Character \n{  \n    name: String!  \n    appearsIn: [Episode!]!\n}\n")),(0,l.kt)("p",null,"The language is pretty readable, but let's go over it so that we can have a shared vocabulary:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"Character")," is a GraphQL Object Type, meaning it's a type with some fields. Most of the types in your schema will be object types. On the Hypi platform, you may build the Schema by adding this object type in the form of a table using Visual builder. (See ",(0,l.kt)("a",{parentName:"p",href:"/docs/lowcode/ui-create-table-vb"},"Create Table"),") . Consider ",(0,l.kt)("inlineCode",{parentName:"p"},"Character")," as a table and its fields as columns.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"appearsIn")," are fields on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Character")," type. That means that ",(0,l.kt)("inlineCode",{parentName:"p"},"name")," and ",(0,l.kt)("inlineCode",{parentName:"p"},"appearsIn")," are the only fields that can appear in any part of a GraphQL query that operates on the ",(0,l.kt)("inlineCode",{parentName:"p"},"Character")," type.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"String")," is one of the built-in scalar types - these are types that resolve to a single scalar object, and can't have sub-selections in the query. We'll go over scalar types more later.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"String!")," indicates that the field is non-nullable, meaning that the GraphQL service promises to always give you a value when you query this field. The field will never be empty. In the type language, we'll represent such fields with an exclamation mark.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},(0,l.kt)("inlineCode",{parentName:"p"},"[Episode!]!")," represents an array of Episode objects. Since it is also non-nullable, you can always expect an array (with zero or more items) when you query the appearsIn field. And since Episode! is also non-nullable, you can always expect every item of the array to be an Episode object."))),(0,l.kt)("p",null,"Now you know what a GraphQL object type looks like, and how to read the basics of the GraphQL type language."),(0,l.kt)("h3",{id:"arguments"},"Arguments"),(0,l.kt)("p",null,"Every field on a GraphQL object type can have zero or more arguments. Look at the ",(0,l.kt)("inlineCode",{parentName:"p"},"length")," field below:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"type Starship {  \n    id: ID!  \n    name: String!  \n    length(unit: LengthUnit = METER): Float\n}\n")),(0,l.kt)("p",null,"All arguments of the field are named. Unlike languages like JavaScript and Python where functions take a list of ordered arguments, all arguments in GraphQL are passed by name specifically. In this case, the length field has one defined argument, unit."),(0,l.kt)("p",null,"Arguments can be either required or optional. When an argument is optional, we can define a default value - if the unit argument is not passed, it will be set to METER by default."),(0,l.kt)("h3",{id:"the-query-and-mutation-types"},"The Query and Mutation types"),(0,l.kt)("p",null,"Most types in your schema will just be normal object types, but there are two special types within a schema:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"schema {  \n    query: Query  \n    mutation: Mutation\n}\n")),(0,l.kt)("p",null,"Every GraphQL service has a query type and may or may not have a mutation type. These types are the same as a regular object type, but they are special because they define the entry point of every GraphQL query. So if you see a query that looks like:"),(0,l.kt)(o.Z,{defaultValue:"query",values:[{label:"GraphQL Query",value:"query"},{label:"Response",value:"response"}],mdxType:"Tabs"},(0,l.kt)(i.Z,{value:"query",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},'query {\n    hero {\n      name\n    }\n    droid(id: "2000") {\n      name\n    }\n}\n'))),(0,l.kt)(i.Z,{value:"response",mdxType:"TabItem"},(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "data": {\n    "hero": {\n      "name": "R2-D2"\n    },\n    "droid": {\n      "name": "C-3PO"\n    }\n  }\n}\n')))),(0,l.kt)("p",null,"It means that the GraphQL service needs to have a Query type with hero and droid fields"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"type Query {\n  hero(episode: Episode): Character\n  droid(id: ID!): Droid\n}\n")),(0,l.kt)("p",null,"Mutations work similarly - you define fields on the Mutation type, and those are available as the root mutation fields you can call in your query."),(0,l.kt)("p",null,'It\'s important to remember that other than the special status of being the "entry point" into the schema, the',(0,l.kt)("inlineCode",{parentName:"p"},"Query"),"and",(0,l.kt)("inlineCode",{parentName:"p"},"Mutation"),"types are the same as any other GraphQL object type, and their fields work exactly the same way."),(0,l.kt)("div",{className:"admonition admonition-note alert alert--secondary"},(0,l.kt)("div",{parentName:"div",className:"admonition-heading"},(0,l.kt)("h5",{parentName:"div"},(0,l.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,l.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},(0,l.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),(0,l.kt)("div",{parentName:"div",className:"admonition-content"},(0,l.kt)("p",{parentName:"div"},"Refer ",(0,l.kt)("a",{parentName:"p",href:"/docs/lowcode/crud"},"CRUD APIs")," to know how mutations and queries work on Hypi's low code platform."))),(0,l.kt)("h3",{id:"scalar-types"},"Scalar types"),(0,l.kt)("p",null,"Check about GraphQL scalar types ",(0,l.kt)("a",{parentName:"p",href:"/docs/lowcode/scalars"},"here"),"."),(0,l.kt)("h3",{id:"enumeration-types"},"Enumeration types"),(0,l.kt)("p",null,"Also called Enums, enumeration types are a special kind of scalar that is restricted to a particular set of allowed values. This allows you to:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"Validate that any arguments of this type are one of the allowed values. "),(0,l.kt)("li",{parentName:"ul"},"Communicate through the type system that a field will always be one of a finite set of values. ")),(0,l.kt)("p",null,"Here's what an enum definition might look like in the GraphQL schema language:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"enum Episode {  \n    NEWHOPE  \n    EMPIRE  \n    JEDI\n}\n")),(0,l.kt)("p",null,"This means that wherever we use the type ",(0,l.kt)("inlineCode",{parentName:"p"},"Episode")," in our schema, we expect it to be exactly one of ",(0,l.kt)("inlineCode",{parentName:"p"},"NEWHOPE"),",",(0,l.kt)("inlineCode",{parentName:"p"},"EMPIRE"),", or ",(0,l.kt)("inlineCode",{parentName:"p"},"JEDI"),"."),(0,l.kt)("p",null,"Note that GraphQL service implementations in various languages will have their own language-specific way to deal with enums. In languages that support enums as a first-class citizen, the implementation might take advantage of that; in a language like JavaScript with no enum support, these values might be internally mapped to a set of integers. However, these details don't leak out to the client, which can operate entirely in terms of the string names of the enum values."),(0,l.kt)("h3",{id:"lists-and-non-null"},"Lists and Non-Null"),(0,l.kt)("p",null,"Object types, scalars, and enums are the only kinds of types you can define in GraphQL. But when you use the types in other parts of the schema, or your query variable declarations, you can apply additional type modifiers that affect the validation of those values. Let's look at an example:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-java"},"type Character {\n  name: String!\n  appearsIn: [Episode]!\n}\n")),(0,l.kt)("p",null,"Here, we're using a String type and marking it as Non-Null by adding an exclamation mark, ! after the type name. This means that our server always expects to return a non-null value for this field, and if it ends up getting a null value that will actually trigger a GraphQL execution error, letting the client know that something has gone wrong."),(0,l.kt)("p",null,"The Non-Null type modifier can also be used when defining arguments for a field, which will cause the GraphQL server to return a validation error if a null value is passed as that argument, whether in the GraphQL string or the variables."),(0,l.kt)("p",null,"The type name within square brackets indicates that the field is a list. Hence ",(0,l.kt)("inlineCode",{parentName:"p"},"appearIn")," is a list of objects of type Episode. Each list item will contain the fields of object ",(0,l.kt)("inlineCode",{parentName:"p"},"Episode"),"."))}m.isMDXComponent=!0}}]);